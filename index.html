<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RockClan Records</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 128 128'%3E%3Crect width='128' height='128' rx='24' fill='%23222236'/%3E%3Cpath d='M82 30 56 64l26 34-18 0-26-34 26-34z' fill='%23ff6a00'/%3E%3C/svg%3E">
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/recharts/umd/Recharts.min.js"></script>
  <style>
    :root{ --bg1:#0b0710;--bg2:#14050a;--accent:#ff6a00;--muted:#a7a0a8;--card:rgba(255,255,255,0.03); }
    *{box-sizing:border-box}
    body{font-family:system-ui,-apple-system,'Segoe UI',Roboto,'Noto Sans KR','Apple SD Gothic Neo','Malgun Gothic',sans-serif;margin:0;color:#eee;background:linear-gradient(180deg,var(--bg1),var(--bg2));}
    header{padding:20px;text-align:center;background:linear-gradient(90deg,rgba(255,255,255,0.02),rgba(0,0,0,0.06));box-shadow:0 6px 30px rgba(0,0,0,0.5)}
    header h1{margin:0;color:var(--accent)}
    header .sub{color:var(--muted);font-size:13px;margin-top:6px}
    nav{display:flex;gap:10px;justify-content:center;padding:10px;background:#14141a;position:sticky;top:0;z-index:2}
    nav button{background:#1a1a22;border:1px solid #232532;color:#ddd;padding:10px 14px;border-radius:10px;cursor:pointer}
    nav button.active{background:var(--accent);color:#111}
    main{max-width:1100px;margin:18px auto;padding:0 16px}
    section{display:none}
    section.active{display:block}
    .card{background:var(--card);padding:14px;border-radius:12px;box-shadow:inset 0 1px 0 rgba(255,255,255,0.02);margin-bottom:16px}
    table{width:100%;border-collapse:collapse}
    th,td{padding:8px 10px;border-bottom:1px solid rgba(255,255,255,0.06);text-align:center}
    th{color:var(--muted);font-size:12px;text-transform:uppercase}
    tr:hover{background:rgba(255,255,255,0.03)}
    .tier-Stone{color:#8b8b8b}.tier-Bronze{color:#cd7f32}.tier-Silver{color:#c0c0c0}.tier-Gold{color:#ffd700}.tier-Diamond{color:#67e8f9}.tier-Legend{color:#ff7f50}
    .muted{color:var(--muted)}
    .match{border:1px solid rgba(255,255,255,0.08);padding:10px;border-radius:10px;background:rgba(255,255,255,0.02);margin-bottom:10px;cursor:pointer}
    .details{display:none;margin-top:8px;font-size:14px;color:#ddd}
    .details.active{display:block}
    .filters{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px}
    .filters > *{flex:1 1 160px}
    .rank-badge{background:#252532;border:1px solid #2f3140;border-radius:8px;padding:2px 8px;font-weight:700;display:inline-block;margin-right:6px}
    .note{font-size:12px;color:#aaa;margin-top:6px}
  </style>
</head>
<body>
  <header>
    <h1>RockClan Records</h1>
    <div class="sub">클랜원 랭킹 • 기록실 • ELO 설명 • 변동 그래프</div>
  </header>

  <nav>
    <button class="tab active" data-tab="players">클랜원 랭킹</button>
    <button class="tab" data-tab="records">기록실</button>
    <button class="tab" data-tab="elo-info">ELO 시스템 설명</button>
    <button class="tab" data-tab="chart">ELO 변동 그래프</button>
  </nav>

  <main>
    <section id="players" class="active">
      <div class="card">
        <h2 style="margin:6px 0;color:var(--accent)">클랜원 랭킹</h2>
        <div class="filters">
          <input id="search" placeholder="id 검색" style="padding:10px;border-radius:8px;border:1px solid #2c2f3a;background:#101018;color:#fff">
          <select id="raceFilter" style="padding:10px;border-radius:8px;border:1px solid #2c2f3a;background:#101018;color:#fff">
            <option value="">종족 전체</option><option>Protoss</option><option>Terran</option><option>Zerg</option><option>Random</option>
          </select>
          <select id="tierFilter" style="padding:10px;border-radius:8px;border:1px solid #2c2f3a;background:#101018;color:#fff">
            <option value="">티어 전체</option><option>Stone</option><option>Bronze</option><option>Silver</option><option>Gold</option><option>Diamond</option><option>Legend</option>
          </select>
        </div>
        <div class="muted" style="font-size:13px;margin-bottom:6px">전체 인원, 종족/티어, 현재 ELO, 승률(%) — <span id="counts"></span></div>
        <table id="players-table">
          <thead><tr><th>Rank</th><th>ID</th><th>종족</th><th>티어</th><th>ELO</th><th>승</th><th>패</th><th>승률</th></tr></thead>
          <tbody></tbody>
        </table>
        <div class="note">* 승/패/승률은 <b>기록실(match)</b>을 기반으로 자동 재계산됩니다. (JSON의 숫자와 달라도 기록이 우선)</div>
      </div>
    </section>

    <section id="records">
      <div class="card">
        <h2 style="margin:6px 0;color:var(--accent)">기록실 (클릭하여 접기/펼치기)</h2>
        <div id="match-list"></div>
      </div>
    </section>

    <section id="elo-info">
      <div class="card">
        <h2 style="margin:6px 0;color:var(--accent)">ELO 시스템 설명</h2>
        <ul>
          <li>초기 ELO: <b>1000</b></li>
          <li>개인전 K-계수: <b>24</b> (팀전은 반영치 <b>60%</b>)</li>
          <li>티어 보정: <code>1 + 0.2 × ΔtierIndex</code> (예: Silver vs Gold)</li>
          <li>본 페이지 랭킹은 JSON의 <b>현재 ELO</b> 값 기준 정렬</li>
          <li>승/패/승률은 아래 기록실 데이터를 다시 집계하여 표시</li>
        </ul>
      </div>
    </section>

    <section id="chart">
      <div class="card">
        <h2 style="margin:6px 0;color:var(--accent)">ELO 변동 그래프</h2>
        <div id="elo-chart" style="width:100%;height:440px"></div>
      </div>
    </section>
  </main>

  <script>
    // 탭 전환
    document.querySelectorAll('nav .tab').forEach(btn=>{
      btn.addEventListener('click', e=>{
        document.querySelectorAll('nav .tab').forEach(b=>b.classList.remove('active'));
        e.currentTarget.classList.add('active');
        document.querySelectorAll('main section').forEach(s=>s.classList.remove('active'));
        document.getElementById(e.currentTarget.dataset.tab).classList.add('active');
      });
    });

    // Recharts 로드 보장
    function ensureRechartsReady(cb){
      let t=0; const h=setInterval(()=>{ t++; if(window.Recharts){clearInterval(h); cb();} if(t>60){clearInterval(h);} },100);
    }

    // Matchday 묶기
    function groupByMatchday(matches){
      const groups=[]; let current=null; let md=0;
      for(const m of matches){
        if(!current || current.date!==m.date || m.map==='Matchday'){
          if(m.map==='Matchday'){ md = current && current.date===m.date ? md+1 : 1; current={date:m.date,index:md,header:m,sets:[]}; groups.push(current); }
          else { if(!current || current.date!==m.date){ md=1; current={date:m.date,index:md,header:null,sets:[]}; groups.push(current); } }
        }
        if(m.map==='Matchday'){ current.header=m; } else { current.sets.push(m); }
      }
      return groups;
    }

    // ---- 데이터 고정(수복) 로직 ----
    function fixData(data){
      // 1) Danny -> DanielK 통합 (매치 교체 + players 삭제)
      if(data.players.some(p=>p.id==='Danny')){
        data.matches.forEach(m=>{
          const rep = name => (name==='Danny' ? 'DanielK' : name);
          if(m.player1) m.player1 = rep(m.player1);
          if(m.player2) m.player2 = rep(m.player2);
          if(Array.isArray(m.team1)) m.team1 = m.team1.map(rep);
          if(Array.isArray(m.team2)) m.team2 = m.team2.map(rep);
          if(Array.isArray(m.winner)) m.winner = m.winner.map(rep);
          if(typeof m.winner==='string') m.winner = rep(m.winner);
        });
        // players: Danny 제거 (DanielK는 유지)
        data.players = data.players.filter(p=>p.id!=='Danny');
      }

      // 2) Chann / Ceta 구분 보호: 매치에 Ceta가 있으면 players에 없을 경우 생성
      const seenNames = new Set();
      data.matches.forEach(m=>{
        [m.player1,m.player2].forEach(x=>{ if(x) seenNames.add(x); });
        [m.team1,m.team2,m.winner].forEach(arr=>{
          if(Array.isArray(arr)) arr.forEach(x=>seenNames.add(x));
          else if(typeof arr==='string') seenNames.add(arr);
        });
      });
      if(seenNames.has('Ceta') && !data.players.some(p=>p.id==='Ceta')){
        data.players.push({id:'Ceta', race:'Protoss', tier:'Silver', elo:1000, played:0, win:0, loss:0, history:[1000]});
      }

      // 3) 기록으로 승/패/경기수 재집계 (JSON 내부 숫자와 불일치시 기록 우선)
      const stat = new Map(); // id -> {played, win, loss}
      function ensure(id){
        if(!stat.has(id)) stat.set(id,{played:0,win:0,loss:0});
        return stat.get(id);
      }
      function addResult(winners, losers){
        winners.forEach(id=>{const s=ensure(id); s.played++; s.win++;});
        losers.forEach(id=>{const s=ensure(id); s.played++; s.loss++;});
      }

      for(const m of data.matches){
        if(m.map==='Matchday') continue; // 헤더는 생략
        // 개인전
        if(m.player1 && m.player2){
          const p1=m.player1, p2=m.player2;
          const w = (typeof m.winner==='string') ? m.winner : null;
          if(w===p1) addResult([p1],[p2]);
          else if(w===p2) addResult([p2],[p1]);
          else { // 승자 정보 없으면 둘 다 played만
            ensure(p1).played++; ensure(p2).played++;
          }
          continue;
        }
        // 팀전
        if(Array.isArray(m.team1) && Array.isArray(m.team2)){
          const t1=m.team1, t2=m.team2;
          if(Array.isArray(m.winner)){
            const wSet = new Set(m.winner);
            const losers = [];
            const winners = [];
            t1.concat(t2).forEach(id=> (wSet.has(id)? winners: losers).push(id));
            if(winners.length && losers.length) addResult(winners, losers);
            else { t1.concat(t2).forEach(id=>ensure(id).played++); }
          }else{
            // 승자 정보 없으면 played만
            t1.concat(t2).forEach(id=>ensure(id).played++);
          }
        }
      }

      // players에 반영 (없는 id는 신규 생성)
      for(const id of stat.keys()){
        if(!data.players.some(p=>p.id===id)){
          data.players.push({id, race:'Protoss', tier:'Silver', elo:1000, played:0, win:0, loss:0, history:[1000]});
        }
      }
      data.players.forEach(p=>{
        const s = stat.get(p.id) || {played:p.played||0, win:p.win||0, loss:p.loss||0};
        p.played = s.played; p.win = s.win; p.loss = s.loss;
      });

      return data;
    }

    // ---- 데이터 로드 ----
    function loadJSON(url){
      return new Promise((resolve,reject)=>{
        const xhr=new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.onreadystatechange=()=>{
          if(xhr.readyState===4){
            if(xhr.status>=200 && xhr.status<300){
              try{
                const data = JSON.parse(xhr.responseText);
                resolve(data);
              }catch(e){ console.error('JSON parse error', e); reject(e); }
            }else{ reject(new Error('HTTP '+xhr.status)); }
          }
        };
        xhr.send();
      });
    }

    function renderAll(data){
      // 고정/수복 처리
      data = fixData(data);

      // Players
      const tbody=document.querySelector('#players-table tbody');
      const s=document.getElementById('search'); const rf=document.getElementById('raceFilter'); const tf=document.getElementById('tierFilter');
      function render(){
        tbody.innerHTML='';
        const kw=(s.value||'').toLowerCase(); const race=rf.value; const tier=tf.value;
        const sorted=[...data.players].sort((a,b)=>b.elo-a.elo).filter(p=>(!kw||p.id.toLowerCase().includes(kw))&&(!race||p.race===race)&&(!tier||p.tier===tier));
        sorted.forEach((p,i)=>{
          const played=p.played||0, win=p.win||0, loss=p.loss||0, wr=played?((win/played)*100).toFixed(1)+'%':'-';
          const tr=document.createElement('tr');
          tr.innerHTML=`
            <td><span class="rank-badge">${i+1}</span></td>
            <td>${p.id}</td>
            <td>${p.race}</td>
            <td class="tier-${p.tier}">${p.tier}</td>
            <td>${Math.round(p.elo)}</td>
            <td>${win}</td>
            <td>${loss}</td>
            <td>${wr}</td>`;
          tbody.appendChild(tr);
        });
        document.getElementById('counts').textContent=\`Players: \${data.players.length} | Matches: \${data.matches.length}\`;
      }
      s.addEventListener('input',render); rf.addEventListener('change',render); tf.addEventListener('change',render); render();

      // Records
      const list=document.getElementById('match-list');
      list.innerHTML='';
      const groups=groupByMatchday([...data.matches].sort((a,b)=>a.date.localeCompare(b.date)));
      groups.forEach(g=>{
        const box=document.createElement('div'); box.className='match';
        const head=document.createElement('div');
        head.innerHTML = g.header ? `<b>${g.date}</b> | Matchday | 승자: ${Array.isArray(g.header.winner)? g.header.winner.join(', '): (g.header.winner||'-')} | 스코어: ${g.header.score||'-'}` : `<b>${g.date}</b> | 세트 모음`;
        const det=document.createElement('div'); det.className='details';
        if(g.sets.length===0){ det.innerHTML='<div class="muted">세트 기록 없음</div>'; }
        else {
          g.sets.forEach(m=>{
            const row=document.createElement('div');
            let s=`• ${m.map} — `;
            if(m.team1 && m.team2){ s+=`${m.team1.join(', ')} vs ${m.team2.join(', ')}`; if(m.winner) s+=` | 승자: ${Array.isArray(m.winner)? m.winner.join(', '): m.winner}`; }
            else if(m.player1 && m.player2){ s+=`${m.player1} vs ${m.player2}`; if(m.winner) s+=` | 승자: ${m.winner}`; }
            if(m.score) s+=` | 스코어: ${m.score}`;
            row.textContent=s; det.appendChild(row);
          });
        }
        box.appendChild(head); box.appendChild(det); box.addEventListener('click',()=>det.classList.toggle('active')); list.appendChild(box);
      });

      // Chart (top 12 lines)
      ensureRechartsReady(()=>{
        try{
          const {LineChart,Line,XAxis,YAxis,Tooltip,Legend,ResponsiveContainer}=Recharts;
          const ppl=[...data.players].sort((a,b)=>b.elo-a.elo).slice(0,12);
          const series={}; ppl.forEach(p=>{ (p.history||[p.elo]).forEach((v,i)=>{ if(!series[i]) series[i]={step:i}; series[i][p.id]=v; }); });
          const chartData=Object.keys(series).sort((a,b)=>a-b).map(k=>series[k]);
          const lines=ppl.map((p,i)=>React.createElement(Line,{key:p.id,type:'monotone',dataKey:p.id,stroke:`hsl(${(i*37)%360},70%,60%)`,strokeWidth:2,dot:false}));
          ReactDOM.render(
            React.createElement(ResponsiveContainer,{width:'100%',height:400},
              React.createElement(LineChart,{data:chartData},
                React.createElement(XAxis,{dataKey:'step'}),
                React.createElement(YAxis,{}),
                React.createElement(Tooltip,{}),
                React.createElement(Legend,{}),
                ...lines
              )
            ),
            document.getElementById('elo-chart')
          );
        }catch(e){ console.error(e); }
      });
    }

    // 동일 폴더의 data.json 로드
    function start(){
      fetch('data.json',{cache:'no-cache'})
        .then(r=>r.json())
        .then(renderAll)
        .catch(err=>{
          console.error('데이터 로드 실패(fetch):', err);
          // XHR fallback
          const xhr=new XMLHttpRequest();
          xhr.open('GET', 'data.json', true);
          xhr.onreadystatechange=()=>{
            if(xhr.readyState===4){
              if(xhr.status>=200 && xhr.status<300){
                try{ renderAll(JSON.parse(xhr.responseText)); }
                catch(e){ console.error('JSON parse error', e); showErr(e); }
              }else{ showErr(new Error('HTTP '+xhr.status)); }
            }
          };
          xhr.send();
        });
    }
    function showErr(err){
      const el=document.createElement('div'); el.className='card'; el.textContent='데이터 로드 실패: '+err;
      document.querySelector('main').prepend(el);
    }
    start();
  </script>
</body>
</html>
